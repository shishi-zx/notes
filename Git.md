# Git命令行操作

* ==使用 Git Bash 打开控制台，使用linux语法操作==
* 使用  `git help 命令` 可以查看具体命令的文档

## 1.1 生成本地仓库

命令：

```bash
git init
```

会生成一个 .git文件夹（隐藏文件），其中存放的是本地库相关的子目录和文件，不建议乱动这个文件夹

## 1.2 设置签名

形式：

* 用户名： tom
* Email地址： TomEmail@google.com

作用：区分不同开发人员的身份，这里的签名与我们登录github或者gitee的用户名邮箱等一点关系都没有

命令：

* 项目级别（仓库级别）：仅在当前本地库范围内有效
  * 此签名保存在 .git文件夹下的 config文件中

```bash
git config user.name tom
git config user.email TomEmail@google.com
```

* 系统用户级别：登录当前操作系统的用户范围，大于项目级别
  * 此签名保存在 `~/.gitconfig` (~:表示home目录)

```bash
git config --global user.name tom
git config --global user.email TomEmail@google.com
```

* 优先级： 就近原则，两者都有的话，项目级别优先于系统用户级别，会采用项目级别的签名，如果两者都没有（是不允许的）



## 1.3 查看状态

命令：

```bash
git status
```

* 查看文件状态，哪些文件处于暂存或者提交状态或者哪些文件自从上次提交后更新了，以及目前处于哪个分支

## 1.4 添加到暂存区和从移除

命令：

```bash
// 添加某个文件到暂存区
git add 文件
// 添加全部更新过的文件到暂存区
git add .
```

* 新文件会被添加到暂存区，等待提交

命令：

```bash
git rm --cached 文件
```

* 从暂存区移除指定文件， 加 -f 可以强制删除，（只是从暂存区删除，不会影响到工作区）

## 1.5 提交到本地仓库

命令：

```bash
git commit
```

* 执行此命令后将进入vim编辑文本，此时我们应该写入对此次提交的描述
* 或者我们可以将这两步合到一起

```bash
git commit -m "描述" 文件
```

## 1.6 版本控制

### 1.6.1 查看历史版本

命令：

```bash
git log
```

* 将会列出每次提交的版本详细信息（只显示本版本之前（历史的前面）的版本，不显示之后）
* 我们此时可以看到 一个 HEAD 指向 master的指针，这个指针指在当前我们最新（最后一次提交的）的版本
* 这个命令我们可以带上参数

```bash
git log --pretty=oneling // 以一行的形式显示一条记录（信息缩减）
git log --oneling // 以一行的形式显示一条记录（信息缩减，hash值也只显示一部分）
git log reflog // 以一行的形式显示一条记录（比起上一行显示指针需要移动的步数）
```

* git reflog 可以显示所有版本

### 1.6.2 切换为历史版本

* 就是更改版本指针（HEAD--> master）

1. 基于索引值切换

```bash
git reset --hard 哈希值（这个值之粘贴git relog 显示出来的部分hash值就行了）
```

* 切换后可以发现我们的所有文件都回到了这个版本

2. 使用 ^ 符号切换：只能后退

```bash
git reset --hard HEAD^  (几个^符号，就回退几步，回到历史之前的版本)
```

3. 使用~符号来切换，只能后退，优化^方式

```bash
git reset --hard HEAD~3 // 表示后退3步
```

### 1.6.3 reset参数详解

`--sort`：只会在本地库移动 HEAD 指针

`--mixed`：只会在本地库移动HEAD指针，重置暂存区

`--hard`：本地库移动HEAD指针，重置暂存区，重置工作区

这三种参数会导致三个区的状态不一致，或者说版本号不一致，此时要注意你的内容是在哪个版本提交的和添加的



### 1.6.4 提示

* 如果删除了某个文件想要找回（之前已将该文件上传至本地库，那么可以回退版本找回该文件）
  * 前提是因为当前版本没有该文件，也就是删除这个操作已经提交过了，所以选择回退之前版本找回
  * 如果只是工作区删除了该文件，并没有提交过这个删除操作的话，直接`git reset --hard HEAD`重置当前的工作区和暂存区即可





## 1.7 比较文件

如果修改了某个文件，想看看与之前的源文件有哪些地方不同的话，可以使用该命令查看

```bash
git diff 文件
```

* git 管理文件以行位单位
  * 也就是修改了某行，会删除原行，添加新行
* `-加红颜色的字显示的行`表示该行被删除了
* `+加绿颜色的字显示的行`表示该行为新加行

不加参数是和暂存区的版本比较

加参数 HEAD 是和本地库的当前版本比较

```bash
git diff HEAD 文件
```

再加参数带上版本选择就是和历史版本比较

比如和上个版本比较

```bash
git diff HEAD^ 文件
```

如果我们不指定比较的文件，那就是比较所有文件



## 1.8 分支管理

### 1.8.1 分支概念

* 在版本控制过程中，使用多条线同时推进多个任务

例如：master为正式版本分支

在下面做两个分支开发两个功能,各个分支自己推进进度，互不影响

* master 
  * feature
    * 1.0
    * 2.0
  * game
    * 1.0
    * 2.0
    * ...

当我们考虑在某个进度时候合并时，在合并推进master的进度



### 1.8.2 查看分支

```bash
git branch -v
```

* 会列出所有分支，并可以看到当前在哪一个分支，一般创建仓库时候就有一个默认的master分支
* -v 列出包括每个分支的当前版本的信息
*  -a 只列出有哪些分支

### 1.8.3 创建分支

```bash
git branch 分支名字
```

* 会创建一个分支

### 1.8.4 切换分支

```bash
git checkout 想要切换的分支名字
```

* 会切换到指定分支，git bash 里可以使用自动补全分支名字

### 1.8.5 合并分支

当我们在支线分支做完开发后，想要合并到主线分支上时候

1. 要先切换到被接受的分支（要合并到的分支，要增加新内容的分支）
2. 执行merge命令

```bash
//切换
git checkout master
//合并
git merge 开发分支（就是从哪一个分支上合并过来）
```



### 1.8.6 解决冲突

* 如果两个分支都同时改了同一个文件，且修改的内容不一致，就会产生冲突

* 当出现这个情况时候，再使用merge命令会提示自动合并失败，需要手动合并，并且可以看到命令行的位置变成了 （分支1 | 分支2），这个时候去查看冲突的文件就可以看到，文件里多了一些标记
  * 可以将标记看做区域划分，分为两块地方（一块为当前分支，一块为另一个分支）
  * <<<<<<HEAD 到 `=========`之间为当前分支的内容
  * `======== `到 >>>>>>>分支名  为另一个分支的内容
* 当我们可以看到哪里冲突了的时候，就可以将标记删除（必须），然后根据需求修改冲突的地方，留下合并后应该的内容
* 此时可以看到命令行的位置还是 （分支1 | 分支2），此时
  * 使用 git status 可以看到修改的部分提示 为 both 开始提示哪个文件未提交
  * 使用git add 文件 将冲突解决提交到暂存区
  * 使用 git status 可以看到提示所有冲突已经解决了，但是现在还是处于正在合并的状态（位置处于（分支1|分支2））
  * 使用 git commit -m "日志" 命令（不能带上文件名参数）来结束本次冲突解决，此时可以看到命令行位置回到了当前分支



## 1.9 本地库与远程库交互

* 基于 用github做远程仓库代码托管

* 首先得创建好本地库

* 然后在远程库（github）上创建好对应的远程仓库（仓库名字可以不同，但是建议相同方便辨认）

* 建立两个仓库的联系（方便两个仓库操作）

  * 方式一：使用https：在github上对应仓库里复制https的链接

  * 为了方便每次推送时候都不用去带上这个地址，我们给这个地址起个别名

    * 使用 git remote -v 查看之前起过的别名

    * 使用命令 git remote add 别名 地址 添加一个别名

      ```bash
       git remote add origin https://github.com/*****
       // 让 origin 代替这个地址名
      ```

    * 然后可以再次查看别名，发现多了两条记录 fetch 和 push

      * fetch用来取回
      * push用来推送

### 1.9.1 推送

命令： git push origin（就是地址别名） 分支名

```bash
//例如推送到master分支
git push origin master
```

* 然后就可以看到远程仓库里有了你的本地仓库的内容



### 1.9.2 克隆

* 将别人仓库的代码克隆到本地
* 首先在别人的远程仓库里的 clone and download 中复制一下地址

命令

```bash
git clone 复制的地址
```

* 就可以在当前本地文件中拿到该远程库中的代码了
* 而且其中包含了 .git文件夹，也就是本地库已经初始化好了，包括origin的别名也创建好了，但是现在并不可以推送你的修改到别人的这个仓库，除非它邀请你作为其中的开发人员

### 1.9.3 邀请别人加入开发团队

* 在github上的对应仓库里的setting中找到开发人员管理一项，选择添加成员，将别人的github账号添加进来就可以了，这个时候就会自动发送邀请链接给别人，（或者自己在刚刚的页面找到copy invite link）发送给别人就行
* 然后等待别人接受就可以了
* 这个时候别人就成为了团队成员，就可以推送代码了

### 1.9.4 拉取

拉取操作 pull = fetch + merge

* 其他团队成员推送过后，自己必须拉取后才能推送
* 分开操作
  * git fetch origin master： 将远程库的master分支下载在本地（并不会覆盖或影响我们的工作区）
    * git checkout origin/master：切换到我们刚刚下载的远程分支上，就可以看到新内容（非自己的）
  * （注意此时不要切换到origin/master分支上，要在自己本地库的分支上）
  * 此时我们可以先看到从远程库下载下来的更新然后再去做合并
  * git merge origin/master：将更新过的内容合并到我们的分支上
* 直接操作
  * git pull origin master：相当于上面的两个操作的合并
* 取决与是否可能会产生冲突，操作是否简单来决定使用哪种方式

### 1.9.5 协同开发时的冲突解决

* 只要是协同开发，一定会发生冲突
* 如果两个人都改了同一文件同一位置，则谁先推送的，谁能推送上去，后推送的必须先拉取才能推送，那么这个时候就产生了冲突
* 此时后面这个人做拉取时候可以发现 ，命令行处于解决冲突的状态，那么我们就自己开始手动去文件里解决冲突 （1.8.6），然后才能推送上去





## 1.10 跨团队协作开发

* 想让别个团队来参加这个项目的开发，可以不用让他们加入到这个仓库中来，而是让他们fork仓库，然后他们基于fork的仓库开发，然后最后再申请pull request 进来原仓库

假如让B fork A的仓库进行开发，那么B fork 后的仓库是属于B的，只不过fork的来源是A

1. B 在github上fork A的仓库 storageA 
2. B 拉取或者clone到本地库
3. 进行开发，然后提交到自己的仓库并push到==自己的==远程库
4. 然后此时要发起 pull requests 请求
   1. 在github仓库中，点击 Pull requests 项
   2. 然后点击 new pull request
   3. 然后会列出你做了哪些修改
   4. 然后点击Create pull request，然后会提示你需要输入本次申请的信息，填写后继续点击Create pull request
   5. 然后就等着A（原仓库主人）去操作了
5. 原仓库主人A
   1. A 点击 Pull requests 项，此时可以看到fork了自己仓库的人给自己pull requests的信息（就是之前B填写的信息）
   2. 点击某条信息进去可以看到具体的情况
   3. 这个时候我们可以看到详情页面，同时可以在conversation项下方反过来给B发信息（点击comment），双发都可以基于这次pull来做相互的发消息沟通
   4. A 点击 详情页面的Commits项可以看B都做了哪些提交，点击Files changed 可以看哪些文件修改了
   5. 如果审核完代码后确定没问题，那么回到conversation项下点击 Merge pull request来合并代码
   6. 然后需要输入此次合并的摘要信息（日志信息），然后点击 confirm merge 确认合并

# SSH免密登录

* 如果在一个没有登录信息凭据管理的系统上用git的话，会多出一些验证身份的步骤，非常麻烦
  * win10 ，win11都有凭据管理
* 所以此时我们就不采用 https的方式，而是采用 ssh的方式来使用
  * 局限性：只能为一个账号设置这个

步骤：

* 进入用户的家目录（不是根目录,~就是家目录）

```bash
cd ~
```

* 生成ssh目录

```bash
ssh-keygen -t rsa -C 邮箱
// -C C是大写 ，邮箱是你的github账号的邮箱
//此命令执行后，会需要确认几步（回车），表示使用默认值就行了
```

* 进入该目录

```bash
cd .ssh/
```

* 可以看到该目录下生成了两个文件 id_rsa 和 id_rsa.pub
* 复制pub文件中的内容
* 回到github上用户的设置中，找到 SSH and GPG keys中，添加新的SSH kys ，然后标题任意，内容为刚刚复制的内容
* 然后我们像https设置别名那样给ssh设置别名就能用了，这两东西在github上都出现在同一地方，直接照以前那样弄就行了



# GIT 工作流

## 1. 集中式工作流

* 以中央仓库作为项目所有的修改实体，所有开发人员都将修改提交到master分支上

## 2. GitFlow 工作流

* 给功能开发，发布准备和维护创立了单独的分支，与Master区分开，让发布迭代过程更流畅。
* 是一种严格的分支模型

例子：

* 一般项目由master分支发布，然后我们在develop分支上做开发，某个版本开发完后，合并到master上上线
* develop分支开发时候，假如有两方面的功能开发游戏和主题两个功能，再基于develop分支创建这两个分支开发，两个功能开发完后合并到develop，表示develop当前版本开发完成
* 加入某天运行时候发现项目有bug，那么基于当前版本的分支创建hotfix（热修复）分支去做bug修复，修复完后，合并到master上上线
* 我们可能会在develop合并到master上时候再创建一个预发布分支（release）来检测当前开发的版本是否没问题，如果有问题就修复，然后再上线到master上
* 一般来说，hotfix修复分支在bug修复后就删除了，release分支可能不会细分出来，而让develop分支来做这个检测

## 3. Forking 工作流

* 基于GitFlow，加上利用了Fork和Pull Requests的功能来达到代码审核目的，更适合安全可靠的管理大型项目